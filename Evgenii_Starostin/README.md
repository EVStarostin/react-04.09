## Урок 7. Концепция Flux на примере использования Redux

Необходимо для Вашего react приложения настроить для работы readux.

1. Для сохранения состояния необходимо реализовать хранилище (store), которое представляет собой комбинацию редьюсеров (reducers), объединенных методов combineReducers. Магазин создаётся при помощи функции createStore(reducer, state, middleware) (см. проект с урока).
2. Для разделения ответственности по обработке частей состояния, необходимо для каждой части состояния создать свой редьюсер. Каждый редьюсер - это функция, которая принимает 2 аргумента: state и action, где state - текущее состояние, которое требуется изменить, action - действие, которое диктует правила изменения этого состояния. При этом результатом работы функции редьюсера - новое состояние, которое эта функция и возвращает. Не забывайте главное правило - состояния иммутабельно, поэтому мы должны всегда порождать новое состояния на основании старого. При этом необходимо производить клонирование тех элементов, которые являются ссылочными, например, массивы, обычно для них хватает вызова функции slice(0). Эти редьюсеры должны быть скомбинированы при создании магазина в один редьюсер. При этом так же необходимо в редьюсре задать для состояния начальный вид, так как изначально state - undefined
3. Для всех требуемых действий необходимо создать соответствующие функции - actions, который возвращают либо объект, который будет передан диспетчеру, либо функцию (в случае асинхронной обработки), которая принимает входной параметр dispatch - функция для асинхронной диспетчеризации.
4. Для увязки нашего приложения с состоянием хранилища, необходимо на главной странице, где отрисовывается основной элемент нашего приложения, обернуть все роуты в элемент - Provider и задать его свойство store = { сюда мы помещаем экземпляр нашего хранилища из п. 2 }
5. При работе с компонентами нашего приложения, которые будет изменять или обращаться к состоянию, мы должны использовать функцию connect из react-redux пакета. Эта функция накладывается на компонент в качестве декоратора (аля @connect()). Первым и самым важным ее параметром является функция, которая принимает наше хранилище (store) и должна вернуть объект. Этот объект, а точнее его свойства, будут записаны в this.props нашего компонента. В том числе в this.props.dispatch будет записана функция диспетчеризации. Вся работа по изменению состояния ведется через нее и вызовы соответствующих действий, который порождают требуемый для диспетчеризации объект (объект или функцию). Более подробно можно почитать по ссылкам.
6. Если нужно, то также можно сделать свои middleware и подключить их в процесс обработки изменения состояния
